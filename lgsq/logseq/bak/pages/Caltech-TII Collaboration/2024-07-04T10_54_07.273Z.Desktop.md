- {{renderer :tocgen2}}
- # Tasks
  collapsed:: true
	- DONE [First meeting](((660f9803-86fb-4d27-8592-f471e3712eba)))
	  :LOGBOOK:
	  CLOCK: [2024-04-04 Thu 23:11:09]--[2024-04-15 Mon 13:16:47] =>  254:05:38
	  :END:
		- DONE Follow up with [instructional](((660fab83-c0af-4019-8e61-d168f0f8ff42))) response
		- DONE Read [[Safety of Linear Systems under Severe Sensor Attacks]]
		  :LOGBOOK:
		  CLOCK: [2024-04-04 Thu 23:06:46]--[2024-04-15 Mon 13:15:11] =>  254:08:25
		  :END:
	- DONE Prepare a small demonstration for second meeting
	  :LOGBOOK:
	  CLOCK: [2024-04-04 Thu 23:05:41]--[2024-04-04 Thu 23:06:44] =>  00:01:03
	  CLOCK: [2024-04-04 Thu 23:11:07]--[2024-04-04 Thu 23:11:07] =>  00:00:00
	  CLOCK: [2024-04-15 Mon 13:16:47]--[2024-04-17 Wed 15:58:33] =>  50:41:46
	  :END:
		- DONE Split the directed attacks to the accelerometer for x, y and z-axis
		  :LOGBOOK:
		  CLOCK: [2024-04-15 Mon 13:18:10]--[2024-04-15 Mon 16:03:38] =>  02:45:28
		  :END:
		- DONE Create a node spinner that can induce a targeted attack on these axes
		  :LOGBOOK:
		  CLOCK: [2024-04-15 Mon 16:03:36]--[2024-04-16 Tue 14:31:10] =>  22:27:34
		  :END:
		- DONE Create a visualisation that captures this behaviour
		  :LOGBOOK:
		  CLOCK: [2024-04-16 Tue 14:31:08]--[2024-04-17 Wed 15:58:32] =>  25:27:24
		  :END:
	- DONE [Second meeting](((66214ed0-8de1-4d80-aa69-b65f4e3be402)))
	  :LOGBOOK:
	  CLOCK: [2024-04-18 Thu 15:52:39]--[2024-04-18 Thu 21:04:48] =>  05:12:09
	  :END:
		- DONE Read [paper]([[Secure State Reconstruction in Differentially Flat Systems Under Sensor Attacks Using Satisfiability Modulo Theory Solving]])
		  id:: 66215121-a83a-4448-9960-9ddf25ef204f
		  :LOGBOOK:
		  CLOCK: [2024-04-18 Thu 21:05:15]--[2024-04-18 Thu 21:05:16] =>  00:00:01
		  CLOCK: [2024-04-18 Thu 21:05:16]--[2024-04-18 Thu 21:05:17] =>  00:00:01
		  CLOCK: [2024-04-18 Thu 21:20:49]--[2024-04-23 Tue 11:55:09] =>  110:34:20
		  :END:
	- DONE [Third meeting](((66260755-1d06-44fc-a270-ca1cbec2c0e2)))
	  :LOGBOOK:
	  CLOCK: [2024-04-22 Mon 10:45:06]--[2024-04-22 Mon 23:57:52] =>  13:12:46
	  :END:
	- DONE Implement simple data extraction and injection module as an external ROS Node
	  id:: 6626c020-2327-420e-b629-822e1cb565d4
	  :LOGBOOK:
	  CLOCK: [2024-04-23 Tue 11:55:14]--[2024-04-30 Tue 20:59:57] =>  177:04:43
	  :END:
		- DONE Research into how the data pipeline is arranged in the flight controller
		  :LOGBOOK:
		  CLOCK: [2024-04-23 Tue 11:55:13]--[2024-04-26 Fri 10:17:44] =>  70:22:31
		  :END:
		- DONE Research existing strategies to achieve the data interception and injection
		  collapsed:: true
		  :LOGBOOK:
		  CLOCK: [2024-04-26 Fri 10:17:47]--[2024-04-30 Tue 15:17:32] =>  100:59:45
		  :END:
			- [[PX4 - Controls]]
		- DONE Test implementation
		  collapsed:: true
		  :LOGBOOK:
		  CLOCK: [2024-04-30 Tue 15:18:31]--[2024-04-30 Tue 15:18:33] =>  00:00:02
		  :END:
			- ((6630d364-3fd7-43f5-9124-1a4b07efaad2))
	- DONE [Fourth meeting](((66386c1a-c19b-46a9-b6ed-2469fe003da8)))
	- DONE Verify and validate: FC's EKF <=> drone in the simulation environment
	  id:: 6633c7e4-1bb7-4a2a-87c6-1d85b1034088
	  :LOGBOOK:
	  CLOCK: [2024-05-06 Mon 09:36:05]--[2024-05-06 Mon 14:22:28] =>  04:46:23
	  :END:
	- DONE [Fifth meeting](((66392067-cc32-4121-922f-0f072aa546e2)))
	- DONE Look up [MATLAB Cells](((66489254-1a0b-4dc1-8620-ba553a40db75)))
	  id:: 663923ce-a39f-45de-b997-6c7b0cdc97c9
	- DONE Try out state reconstruction method with simple example
	  id:: 6639243a-3acc-4468-a10d-594e60b555ef
	  :LOGBOOK:
	  CLOCK: [2024-05-16 Thu 14:23:26]--[2024-05-21 Tue 21:55:33] =>  127:32:07
	  :END:
	- DONE [Sixth meeting](((66697fd7-73e3-4c64-b3db-f168ea9582ff)))
	- DOING (Try out)->(Implement) ~~simple~~ example with (full system)->(1D Drone Sim)
	  :LOGBOOK:
	  CLOCK: [2024-05-21 Tue 21:58:08]
	  :END:
		- DONE Design [the system](((665a0dc2-ee9a-4ccf-81b9-6e15aeac06c5)))
	- DOING Develop the secure state reconstructor
	  :LOGBOOK:
	  CLOCK: [2024-05-31 Fri 21:47:57]
	  CLOCK: [2024-05-31 Fri 21:48:12]
	  :END:
	- DONE [Seventh meeting](((6669a432-d780-4cda-8b74-aec71aa8a5d6)))
	  SCHEDULED: <2024-06-03 Mon 20:00>
	  :LOGBOOK:
	  CLOCK: [2024-06-03 Mon 19:49:36]--[2024-06-03 Mon 22:14:01] =>  02:24:25
	  :END:
	- DONE Create GitHub repository and add `xiaotan-git` to it
	  id:: 665e07f3-91f8-4e6b-a82d-e9b109c9ac74
	  :LOGBOOK:
	  CLOCK: [2024-06-05 Wed 10:20:22]--[2024-06-05 Wed 16:31:18] =>  06:10:56
	  :END:
- # Notes
	- ## MATLAB Cells
	  id:: 66489254-1a0b-4dc1-8620-ba553a40db75
	  collapsed:: true
		- A flexible data container that can hold different types of data.
		- It is primarily used for:
			- storing heterogeneous data,
			- organising text data, and
			- creating flexible structures.
		- Working with:
			- ```matlab
			  %% Create
			  myCellArray = {'Hello', [1 2 3], true};  
			  myCellArray = cell(3, 2); % Creates a 3x2 cell array  
			  ```
			- ```matlab
			  %% Access
			  value = myCellArray{1};   % Accesses the content of the first cell
			  ```
			- ```matlab
			  %% Edit
			  myCellArray(2,1) = 100;   % Changes content within the cell array 
			  ```
	- ## Instructional
	  id:: 660fab83-c0af-4019-8e61-d168f0f8ff42
	  collapsed:: true
		- ### Running the SITL Simulation
		  collapsed:: true
			- First pull the repository with the faulty controller implementation.
			- ```bash
			  git clone --recursive https://www.github.com/tiiuae/px4-firmware.git -b faulty-controller
			  cd px4-firmware
			  # To make life simpler, export the `FIRMWARE_DIR`
			  # variable so that the simulation can then be launched from anywhere
			  echo export FIRMWARE_DIR=$(pwd) > ~/.bashrc
			  source ~/.bashrc
			  ```
			- We can run this simulation in a container, but first we need to pull the appropriate docker image:
			- ```bash
			  docker pull px4io/px4-dev-simulation-jammy:latest
			  ```
			- The simulation can be launched with the following command:
			- ```bash
			  # Run once to ensure that any remote client (like the container)
			  # to connect to the X Server. Essentially allows you to run GUI
			  # apps launched in the container to be forwarded to your local system
			  xhost +
			  
			  # This command serves multiple purposes
			  # We mount the firmware root directory into the container to build the SITL environment
			  # We forward the X11 server so that the Gazebo simulator GUI runs on local machine
			  # We set network=host so that we can alter subscribe to the rostopics through the DDS
			  docker run -it --privileged --rm \
			    -v ${FIRMWARE_DIR}:/home/user/Firmware:rw \
			    -v /tmp/.X11-unix:/tmp/.X11-unix:ro \
			    -e DISPLAY=${DISPLAY} \
			    -e LOCAL_USER_ID="$(id -u)" \
			    -w /home/user/Firmware \
			    --network=host  \
			    --name=container_name px4io/px4-dev-simulation-jammy \
			    make px4_sitl gz_x500
			  ```
		- ### Injecting Faults in Accelerometer
		  collapsed:: true
			- The implementation has the fault injection features built in. In order to inject targeted and specific faults to accelerator sensor modules, you can type the following commands in the MAVLink console running within the same terminal where the SITL simulation is active.
			- ```bash
			  param set SENS_ACCEL_FAULT 1
			  param set SENS_ACCEL_SET <Any Float Value>
			  ```
			- The first command exposes the fault interface within the firmware, and the second command sets the Accelerometer x, y, and z values to the float value provided.
			- **Note:** Before closing the simulator make sure to revert the values:
			- ```bash
			  param set SENS_ACCEL_SET 0
			  param set SENS_ACCEL_FAULT 0
			  ```
		- ### Imitating an attack
		  collapsed:: true
			- The plan of action will be to design a program (either a ROS 2 node or a standalone script) that changes the `SENS_ACCEL_SET` parameter according to a predefined behaviour of the malicious agent.
			- As the agent will have access to the system's internal dynamics, they will also be a node in the ROS 2 network and will subscribe to the necessary topics being published from the PX4 flight controller.
	- ## ROS 2 Modular Control
	  id:: 6630d364-3fd7-43f5-9124-1a4b07efaad2
	  collapsed:: true
		- There are three ROS 2 nodes:
			- **EKF**
				- ![ekf.png](../assets/ekf_1714475976448_0.png)
				- Subscribes to the `vehicle_local_position` topic from the Flight Controller.
				- Publishes ground truth (`gt`) and raw copy (`raw`), separately.
			- **Attacker**
				- ![attacker.png](../assets/attacker_1714475981345_0.png)
				- Subscribes to the `raw` position and introduces an attack. In this case it can be a simple halving operation.
				- ```cpp
				  void Attacker::attack(VehicleLocalPosition& copy)
				  {
				      if (attack_flag)
				      {
				          copy.x /= 2;
				          copy.y /= 2;
				          copy.z /= 2;
				      } else {
				          copy.x *= 1;
				          copy.y *= 1;
				          copy.z *= 1;
				      }
				  }
				  ```
				- It then publishes an `attacked` version of the `gt`.
			- **Controller**
				- ![controller.png](../assets/controller_1714475986120_0.png)
				- Uses the `attacked` and `gt` versions of `vehicle_local_position` to generate a controller input.
				- In this example, we are using a velocity controller - it can also accommodate acceleration controls.
				- Basic averaging operation is used to merge the `gt` with the `attacked` EKF outputs.
				- ```cpp
				  VehicleLocalPosition reference;
				  this->state_merger(reference); // <-- Standard averaging
				  
				  vx = coordinates[target][0] - reference.x;
				  vy = coordinates[target][1] - reference.y;
				  vz = coordinates[target][2] - reference.z;
				  
				  if (abs(vx) > 5)
				  {
				  	  vx = vx / abs(vx) * 5; // Input in x
				  }
				  if (abs(vy) > 5)
				  {
				  	  vy = vy / abs(vy) * 5; // Input in y
				  }
				  if (abs(vz) > 5)
				  {
				  	  vz = vz / abs(vz) * 5; // Input in z
				  }
				  
				  float vxs = vx * vx;
				  float vys = vy * vy;
				  float vzs = vz * vz;
				  float separation = (float)sqrt(vxs + vys + vzs);
				  
				  if (separation < threshold)
				  {
				      target++;
				      if (target > (int)coordinates.size() - 1)
				      {
				        	target = 0;
				      }
				  }
				  
				  // offboard_control_mode needs to be paired with trajectory_setpoint
				  publish_offboard_control_mode();
				  publish_trajectory_setpoint();
				  ```
		- The mission is square periodic.
		- The attack is introduced at a random time point. The results while observing the ground truth are shown below:
		- ![results.png](../assets/results_1714476410791_0.png)
	- ## 1D Drone System
	  id:: 665a0dc2-ee9a-4ccf-81b9-6e15aeac06c5
	  collapsed:: true
		- $$A=\begin{bmatrix}0 && 0 \\ 0 && 1\end{bmatrix} \space \textbf{x} = \begin{bmatrix}x \\ \dot{x}\end{bmatrix}$$
		- $$B=\begin{bmatrix}0 \\ 1\end{bmatrix} \space \textbf{u} = \begin{bmatrix}u_x\end{bmatrix}$$
		- $$C=\begin{bmatrix}1 && 0 && 0 && 0 \\ 0 && 1 && 0 && 0 \\ 0 && 0 && 1 && 0 \\ 0 && 0 && 0 && 1 \end{bmatrix} \space \textbf{y} = \begin{bmatrix}x_1 \\ \dot{x}_1 \\ x_2 \\ \dot{x}_2\end{bmatrix}$$
		- $$H=\begin{bmatrix}1 && 0 && 0 && 0\\ 0 && -1 && 0 && 0 \\ 0 && 0 && 1 && 0\\ 0 && 0 && 0 && -1\end{bmatrix} \space \textbf{q} = \begin{bmatrix}4 \\ 4 \\ 4 \\ 4\end{bmatrix}$$
- # Meetings
  tag:: #MEETING
	- ## 3 June 2024
	  id:: 6669a432-d780-4cda-8b74-aec71aa8a5d6
	  collapsed:: true
		- **Attendees**
		  collapsed:: true
			- Xiao Tan
			- Junior Sundar
		- **Goal**
		  collapsed:: true
			- Clarity on the work being done.
		- **Agenda**
		  collapsed:: true
			- Clarify the matrix dimensions.
			- Follow up on progress.
		- **Minutes**
		  collapsed:: true
			- *Questions:*
				- Is the following 1D sensor case feasible:
					- ```cpp
					  std::vector<double> sensor_vector{static_cast<double>(ekf_1.x),
					                                    static_cast<double>(ekf_1.vx),
					                                    static_cast<double>(ekf_2.x),
					                                    static_cast<double>(ekf_2.vx)};
					  ```
				- Verify [this equation](((665a0dc2-ee9a-4ccf-81b9-6e15aeac06c5))).
				- Clarify function of `nchoosek`.
				- Are we essentially overwriting the `O_Gamma` and `Y_Gamma` in `secure_state_estimator.m`?
				  collapsed:: true
					- ```MATLAB
					  for i = 1:size(comb,1)
					      % prepare all matrices
					      Gamma = comb(i,:);
					      O_Gamma = zeros((p-s)*n,n);
					      Y_Gamma = zeros((p-s)*n,1);
					  
					      for j = 1:size(Gamma,2)
					          sensor_ind = Gamma(j);
					          O = Oi_cell{sensor_ind};
					          Y_tilde = y_vec(sensor_ind,t-n+1:t);
					          O_Gamma(n*(j-1)+1:n*j,:) = O;  %% THIS PART IN PARTICULAR
					          Y = Y_tilde' - Fi_cell{sensor_ind}*reshape(u_vec(:,t-n+1:t),[],1);
					          Y_Gamma(n*(j-1)+1:n*j,1) = Y;
					      end
					      % least square solution
					      % suppress warning
					      warning('off', 'MATLAB:rankDeficientMatrix')
					      x0_gamma = O_Gamma\Y_Gamma;
					        
					      % threshold compare
					      if norm(Y_Gamma - O_Gamma*x0_gamma)>0.001
					          % disp(['No initial state for sensors ' num2str(Gamma) '!']);  
					          % disp(['fitting error->' num2str(norm(Y_Gamma - O_Gamma*x0_gamma)) ', fail to convince'])
					      else
					          % disp(['Found initial state for sensors ' num2str(Gamma) ' at time ' num2str(t) '!']);
					          % disp('The possible x0 is ')
					          % disp(num2str(x0_gamma))
					          Gamma_set_new(end+1,:) = Gamma;
					  
					          if rank(O_Gamma)<n
					              % null space
					              A_gamma = null(O_Gamma,1e-4);
					          else
					              A_gamma = 0;
					          end
					  
					          x0_prob.x0 = x0_gamma;
					          x0_prob.A_gamma = A_gamma;
					          x0_prob.Gamma = Gamma;
					          X0_cell{end+1} = x0_prob;
					      end
					  end
					  ```
				- Clarify this chunk of code in `secure_state_estimator.m`:
				  collapsed:: true
					- ```MATLAB
					  % now check if subspac:kernal of O_G must be a subset of kernal of HA^t
					  if norm(A_x0)>0.1
					      for j = 1:size(A_x0,2)
					          M = [H; H*A; H*A^2; H*A^3]*A_x0(:,j);
					          if norm(M)>=0.0001
					              error(['possible subspace ' num2str(A_x0(:,j)') ' is not in safe set']);
					          end
					      end
					  
					      A_xt(:,j) = H*A^3*A_x0(:,j);
					  end
					  ```
			- *Responses:*
			  collapsed:: true
				- Assume at most how many sensors are being attacked (this is a prerequisite)!!
				- As for input vectors:
					- First open-loop
					- Second closed-loop --> Assume that a sensor is "trustworthy" -> In what sense? Doesn't really matter because we can guarantee stability.
					- Maybe we can use ML to identify attacked sensor to place trustworthy label.
				- What could go wrong with this implementation:
					- measurement from EKF may not be accurate.
					- model is very simple, may not be the true model, tuning may be required here.
		- **Action Points**
		  collapsed:: true
			- ((665e07f3-91f8-4e6b-a82d-e9b109c9ac74))
	- ## 20 May 2024
	  id:: 66697fd7-73e3-4c64-b3db-f168ea9582ff
	  collapsed:: true
		- **Attendees**
		  collapsed:: true
			- Xiao Tan
			- Junior Sundar
		- **Goals**
			- Understand the workings of the nominal controller and the safety filter
		- **Agenda**
		  collapsed:: true
			- Follow up on what was understood from self learning
			- Go through new powerpoint
		- **Minutes**
		  collapsed:: true
			- Follow up
				- Running matrix operations on GPU is a feasible option.
				- Will need to benchmark the point at which this becomes efficient because excess transfer of data between CPU and GPU when operations can be done efficiently in CPU is suboptimal.
				- Efficient algorithm is still in development by Xiao.
			- Nominal Control
				- *Inputs:* Possible states $X^t$ at $t$ on human remote input
				- *Outputs:* Desired control $u_{nom}$
				- $u_{nom}$ is hard to choose since $X^t$ is a matrix of estimates. For now,
				    it is constant and time-dependent.
			- Safety Filter
				- *Inputs:* Nominal control $u_{nom}$
				- *Outputs:* Safe control $u_{safe}$ with least deviation from $u_{nom}$
				- $Hx + q \leq 0$
					- Here, $H$ and $q$ matrices are obtained by defining safety bounds for the different states.
				- $H(Ax + Bu) + q \geq (1 - \gamma) Hx + q$
					- Basically states that if system starts within safe region, and the above control barrier function rule is held, it will always remain within safe region.
					- Here $\gamma$ relates to how aggressive the filter is going to be.
						- With a larger value, it will only trigger as system reaches close to boundary.
						- With smaller value the filter starts affecting from a bit further in.
				- No guarantee of feasiblity of optimisation problem to find $u_{safe}$ if the equation of quadratic programming fails, then the system is aborted.
		- **Action Items**
		  collapsed:: true
			- No meeting for next week. Set it for the week after.
	- ## 6 May 2024
	  id:: 66392067-cc32-4121-922f-0f072aa546e2
	  collapsed:: true
		- **Attendees**
			- Xiao Tan
			- Junior Sundar
		- **Goals**
			- Understand the secure state reconstruction algorithm
		- **Agenda**
			- Go through the provided powerpoint
			- Discuss the MATLAB codes
		- **Minutes**
			- Plant is a Discrete Time state-system A, B, C with attack signal $e(\tau) \in \mathbb{R}^p$ where $s<p$ sensors are attacked.
			- Should aim to have something to demonstrate by [[May 23rd, 2024]].
			- No tight deadline for this (as December is expected deadline).
		- **Action Items**
			- ((663923ce-a39f-45de-b997-6c7b0cdc97c9))
			- ((6639243a-3acc-4468-a10d-594e60b555ef))
	- ## 2 May 2024
	  id:: 66386c1a-c19b-46a9-b6ed-2469fe003da8
	  collapsed:: true
		- **Attendees**
			- Xiao Tan
			- Junior Sundar
			- Martin Andreoni
			- Willian Lunardi
		- **Goal**
			- Receive feedback and opinion on the rough implementation of the external EKF, Attacker and Controller
		- **Agenda**
			- Feedback
			- Next steps
		- **Minutes**
			- Xiao wants the controller to only receive the attacked signal, not both the attacked and the ground truth.
			- Rather than sending the `px4_msgs/msg/VehicleLocalPosition` values to the controller, we want to send a custom message type that carries a different set of data inside it.
			- Possibly, a matrix?
		- **Action Items**
			- ((6633c7e4-1bb7-4a2a-87c6-1d85b1034088))
			  :LOGBOOK:
			  CLOCK: [2024-04-04 Thu 23:04:14]
			  :END:
	- ## 22 April 2024
	  id:: 66260755-1d06-44fc-a270-ca1cbec2c0e2
	  collapsed:: true
		- **Attendees**
			- Xiao Tan
			- Junior Sundar
			- Martin Andreoni
			- Willian Lunardi
		- **Goal**
			- Discuss the technical details of the experimentation (block diagram)
		- **Agenda**
			- Understand how the system is designed in terms of its block diagram
			- Brainstorm strategies to implement this in PX4
		- **Minutes**
			- Xiao wants the addition to be an external ROS Node that intercepts the EKF output and draws it out of the FC into a ROS Node.
			- I think there are two ways to go about this problem:
				- Directly bake in the modules into the flight controller firmware
				- Identify a method to bring out the data from the FC into a ROS Node and then work and feed it back in
			- Also drew a block diagram:
			- ![virtual-sensor.png](../assets/virtual-sensor_1713852326383_0.png)
		- **Action Items**
			- ((6626c020-2327-420e-b629-822e1cb565d4))
			  :LOGBOOK:
			  CLOCK: [2024-04-04 Thu 23:04:14]
			  :END:
	- ## 18 April 2024
	  id:: 66214ed0-8de1-4d80-aa69-b65f4e3be402
	  collapsed:: true
		- **Attendees**
			- Xiao Tan
			- Junior Sundar
			- Willian Lunardi
		- **Goal**
			- Follow up on previous discussion to explore scope and range of the project.
		- **Agenda**
			- Show the demonstration of the attacker to the accelerometer
			- Discuss whether this is the method required or if something new is in the works?
		- **Minutes**
			- They want to go for a simpler example use case:
				- EKF is the ground truth
				- Create a copy of the EKF and the attacker spoofs this value
				- This is then merged with GT EKF and then sent to the plant which is the drone.
			- Easier to only work in the planar case. So drone takes off and moves in the single place in some planar circuit.
			- Design of Experiment:
				- Twin of EKF, so the code can remain within the same module -> Just create a copy of the data output.
				- Online safe controller also needs to be implemented.
			- Future direction:
				- Some other work undertaken in the lab can use the results from this experiments.
				- How to fuse state estimation under sensor attacks more efficiently?
		- **Action Items**
			- ((66215121-a83a-4448-9960-9ddf25ef204f))
	- ## 4 April 2024
	  id:: 660f9803-86fb-4d27-8592-f471e3712eba
	  collapsed:: true
		- **Attendees**
		  collapsed:: true
			- Xiao Tan
			- Junior Sundar
			- Martin Andreoni
			- Willian Lunardi
		- **Goal**
			- Sync up on collaboration opportunity
		- **Agenda**
		  collapsed:: true
			- Discuss the research scope
			- Identify applicability of use case
			- Identify possible collaboration space
		- **Minutes**
		  collapsed:: true
			- The implementation is a "Safety Filter" that identifies when a malicious agent has attacked a sensor module and is directing it towards an unsafe region.
			- Attacker knows everything of the system.
			- Assume that all internal states can be measured and are observable.
			- In practice 's' out of 'p' total sensors can be attacked.
		- **Action Items**