@document.meta
title: Caltech-TII Collaboration
description: Possible collaboration opportunity with Caltech
authors: juniorsundar
categories: [
    task
]
created: 2024-04-04T23:08:32+0400
updated: 2024-04-30T22:35:29+0400
version: 1.1.1
@end

* (x) {:$/journal/2024/04/04:** Xiao Tan / Junior Sundar -- X6 Security Collaboration}[First meeting]
** (x) Follow up with {* Instructional}[instructional] response
** (x) Read {:$/research/literature-review/tan2024:}[paper]

* (x) Prepare a small demonstration for second meeting
** (x) Split the directed attacks to the accelerometer for x, y and z-axis
** (x) Create a node spinner that can induce a targeted attack on these axes
** (x) Create a visualisation that captures this behaviour

* (x) {:$/journal/2024/04/18:** Xiao Tan / Junior Sundar -- Follow up}[Second meeting]
** (x) Read {:$/research/literature-review/shoukry2015:}[paper]

* (x) Third meeting

* (x) Implement simple data extraction and injection module as an external ROS Node
** (x) Research into how the data pipeline is arranged in the flight controller
** (x) Research existing strategies to achieve the data interception and injection
   {:$/technical/px4/controls:}[PX4 - Controls]

** (x) Test implementation 
   {* ROS 2 Modular Control}[ROS 2 Modular Control]

* Fourth meeting

   ===
___

* Instructional

** Running the SITL Simulation

   First pull the repository with the faulty controller implementation.

   @code bash
   git clone --recursive https://www.github.com/tiiuae/px4-firmware.git -b faulty-controller
   cd px4-firmware
   # To make life simpler, export the `FIRMWARE_DIR`
   # variable so that the simulation can then be launched from anywhere
   echo export FIRMWARE_DIR=$(pwd) > ~/.bashrc
   @end

   We can run this simulation in a container, but first we need to pull the
   appropriate docker image:

   @code bash
   docker pull px4io/px4-dev-simulation-jammy:latest
   @end

   The simulation can be launched with the following command:

   @code bash
   # Run once to ensure that any remote client (like the container)
   # to connect to the X Server. Essentially allows you to run GUI
   # apps launched in the container to be forwarded to your local system
   xhost +

   # This command serves multiple purposes
   # We mount the firmware root directory into the container to build the SITL environment
   # We forward the X11 server so that the Gazebo simulator GUI runs on local machine
   # We set network=host so that we can alter subscribe to the rostopics through the DDS
   docker run -it --privileged --rm \
           -v ${FIRMWARE_DIR}:/home/user/Firmware:rw \
           -v /tmp/.X11-unix:/tmp/.X11-unix:ro \
           -e DISPLAY=${DISPLAY} \
           -e LOCAL_USER_ID="$(id -u)" \
           -w /home/user/Firmware \
           --network=host  \
           --name=container_name px4io/px4-dev-simulation-jammy \
           make px4_sitl gz_x500
   @end

** Injecting Faults in Accelerometer

   The implementation has the fault injection features built in. In order to
   inject targeted and specific faults to accelerator sensor modules, you can
   type the following commands in the MAVLink console running within the same
   terminal where the SITL simulation is active.

   @code bash
   param set SENS_ACCEL_FAULT 1
   param set SENS_ACCEL_SET <Any Float Value>
   @end

   The first command exposes the fault interface within the firmware, and the
   second command sets the Accelerometer x, y, and z values to the float value
   provided.

   *Note:* Before closing the simulator make sure to revert the values:
   @code bash
   param set SENS_ACCEL_SET 0
   param set SENS_ACCEL_FAULT 0
   @end

*** Imitating an attack

    The plan of action will be to design a program (either a ROS 2 node or a
    standalone script) that changes the `SENS_ACCEL_SET` parameter according to a
    predefined behaviour of the malicious agent.

    As the agent will have access to the system's internal dynamics, they will
    also be a node in the ROS 2 network and will subscribe to the necessary
    topics being published from the PX4 flight controller.

    ===
___

* ROS 2 Modular Control

** EKF

   .image assets/ekf.png

   Subscribes to the `vehicle_local_position` topic from the Flight Controller.

   Publishes ground truth (`gt`) and raw copy (`raw`), separately.

** Attacker

   .image assets/attacker.png

   Subscribes to the `raw` position and introduces an attack. In this case it
   can be a simple halving operation.

   @code cpp
   void Attacker::attack(VehicleLocalPosition& copy)
   {
       if (attack_flag)
       {
           copy.x /= 2;
           copy.y /= 2;
           copy.z /= 2;
       } else {
           copy.x *= 1;
           copy.y *= 1;
           copy.z *= 1;
       }
   }
   @end

   It then publishes an `attacked` version of the `gt`.

** Controller

   .image assets/controller.png

   Uses the `attacked` and `gt` versions of `vehicle_local_position` to
   generate a controller input.

   In this example, we are using a velocity controller - it can also
   accommodate acceleration controls.

   Basic averaging operation is used to merge the `gt` with the `attacked` EKF
   outputs.

   @code cpp
   VehicleLocalPosition reference;
   this->state_merger(reference); // <-- Standard averaging

   vx = coordinates[target][0] - reference.x;
   vy = coordinates[target][1] - reference.y;
   vz = coordinates[target][2] - reference.z;

   if (abs(vx) > 5)
   {
       vx = vx / abs(vx) * 5; // Input in x
   }
   if (abs(vy) > 5)
   {
       vy = vy / abs(vy) * 5; // Input in y
   }
   if (abs(vz) > 5)
   {
       vz = vz / abs(vz) * 5; // Input in z
   }

   float vxs = vx * vx;
   float vys = vy * vy;
   float vzs = vz * vz;
   float separation = (float)sqrt(vxs + vys + vzs);

   if (separation < threshold)
   {
       target++;
       if (target > (int)coordinates.size() - 1)
       {
           target = 0;
       }
   }

   // offboard_control_mode needs to be paired with trajectory_setpoint
   publish_offboard_control_mode();
   publish_trajectory_setpoint();
   @end

   ---

  The mission is square periodic.

  The attack is introduced at a random time point. The results while observing
  the ground truth are shown below:

  .image assets/results.png

